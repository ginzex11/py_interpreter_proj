"""
Unit tests for the Parser class from the interpreter_logic.parser module.

This test suite uses the unittest framework to validate that the Parser class correctly
parses sequences of tokens into an Abstract Syntax Tree (AST). The tests cover various
language constructs, including arithmetic operations, function calls, logical operations,
lambda expressions, and function definitions.

Classes:
- TestParser: Contains test methods to validate the functionality of the Parser.

Methods:
- run_test_case: Helper method to compare the expected AST with the actual AST generated by the Parser.
- Various test methods to validate correct parsing of different language constructs.
"""

import unittest
from interpreter_logic.lexer import Lexer
from interpreter_logic.parser import Parser


class TestParser(unittest.TestCase):
    """
    Test case class for validating the Parser class functionality.
    """

    def run_test_case(self, input_code, expected_ast):
        """
        Asserts that the Parser correctly generates the expected AST for the given input code.

        Args:
            input_code (str): The input source code.
            expected_ast (str): The expected string representation of the AST.
        """
        lexer = Lexer(input_code)
        tokens = lexer.tokenize()
        parser = Parser(tokens)
        ast = parser.parse_program()
        self.assertEqual(repr(ast), expected_ast)

    def test_arithmetic_operation(self):
        """
        Tests parsing of a simple arithmetic operation.
        """
        input_code = "4 + 3"
        expected_ast = "Program(body=[BinaryOp(left=Literal(value=4), operator='+', right=Literal(value=3))])"
        self.run_test_case(input_code, expected_ast)

    def test_function_call(self):
        """
        Tests parsing of a function call.
        """
        input_code = "factorial(5)"
        expected_ast = "Program(body=[Call(func=Identifier(name=factorial), args=[Literal(value=5)])])"
        self.run_test_case(input_code, expected_ast)

    def test_logical_operation(self):
        """
        Tests parsing of a logical operation.
        """
        input_code = "(x > 0) && (y < 10)"
        expected_ast = "Program(body=[BinaryOp(left=BinaryOp(left=Identifier(name=x), operator='>', right=Literal(value=0)), operator='&&', right=BinaryOp(left=Identifier(name=y), operator='<', right=Literal(value=10)))])"
        self.run_test_case(input_code, expected_ast)

    def test_lambda_expression(self):
        """
        Tests parsing of a lambda expression.
        """
        input_code = "(Lambd x.(Lambd y. (x + y)))"
        expected_ast = "Program(body=[Lambda(params=[Identifier(name=x)], body=Lambda(params=[Identifier(name=y)], body=BinaryOp(left=Identifier(name=x), operator='+', right=Identifier(name=y))))])"
        self.run_test_case(input_code, expected_ast)

    def test_function_definition_with_logic(self):
        """
        Tests parsing of a function definition with a logical operation.
        """
        input_code = "Defun {'name': 'factorial', 'arguments': (n,)} (n == 0) or (n * factorial(n - 1))"
        expected_ast = (
            "Program(body=[FunctionDef(name=Identifier(name=factorial), params=[Identifier(name=n)], body=BinaryOp(left=BinaryOp(left=Identifier(name=n), operator='==', right=Literal(value=0)), operator='or', right=BinaryOp(left=Identifier(name=n), operator='*', right=Call(func=Identifier(name=factorial), args=[BinaryOp(left=Identifier(name=n), operator='-', right=Literal(value=1))]))))])"
        )
        self.run_test_case(input_code, expected_ast)

    def test_extra_parenthesis(self):
        """
        Tests parsing of an expression with extra parentheses.
        """
        input_code = "((x + y))"
        expected_ast = "Program(body=[BinaryOp(left=Identifier(name=x), operator='+', right=Identifier(name=y))])"
        self.run_test_case(input_code, expected_ast)

    def test_unmatched_parenthesis(self):
        """
        Tests that unmatched parentheses raise an exception.
        """
        input_code = "(x + (y * 2)"
        with self.assertRaises(Exception):
            lexer = Lexer(input_code)
            tokens = lexer.tokenize()
            parser = Parser(tokens)
            parser.parse_program()

    def test_missing_function_name(self):
        """
        Tests that missing function name in a function definition raises an exception.
        """
        input_code = "Defun {'name': '', 'arguments': (n,)} (n == 0) or (n * factorial(n - 1))"
        with self.assertRaises(Exception):
            lexer = Lexer(input_code)
            tokens = lexer.tokenize()
            parser = Parser(tokens)
            parser.parse_program()

    def test_missing_argument_in_call(self):
        """
        Tests that a function call with missing arguments is correctly handled.
        """
        input_code = "factorial()"
        expected_ast = "Program(body=[Call(func=Identifier(name=factorial), args=[])])"
        self.run_test_case(input_code, expected_ast)

    def test_empty_function_body(self):
        """
        Tests parsing of a function definition with an empty body.
        """
        input_code = "Defun {'name': 'empty', 'arguments': ()} {}"
        expected_ast = "Program(body=[FunctionDef(name=Identifier(name=empty), params=[], body=None)])"
        self.run_test_case(input_code, expected_ast)

    # In your interpreter tests (e.g., test_interpreter.py)

    def test_assignment(self):
        """
        Tests parsing of a simple assignment.
        """
        input_code = "x = 10"
        expected_ast = "Program(body=[Assignment(target=Identifier(name=x), value=Literal(value=10))])"
        self.run_test_case(input_code, expected_ast)

    def test_equality_comparison(self):
        """
        Tests parsing of an equality comparison.
        """
        input_code = "x == 10"
        expected_ast = "Program(body=[BinaryOp(left=Identifier(name=x), operator='==', right=Literal(value=10))])"
        self.run_test_case(input_code, expected_ast)

    def test_recursive_function(self):
        """
        Tests parsing of a recursive function definition.
        """
        input_code = "Defun {'name': 'factorial', 'arguments': (n,)} (n == 0) or (n * factorial(n - 1))"
        expected_ast = (
            "Program(body=[FunctionDef(name=Identifier(name=factorial), params=[Identifier(name=n)], body=BinaryOp(left=BinaryOp(left=Identifier(name=n), operator='==', right=Literal(value=0)), operator='or', right=BinaryOp(left=Identifier(name=n), operator='*', right=Call(func=Identifier(name=factorial), args=[BinaryOp(left=Identifier(name=n), operator='-', right=Literal(value=1))]))))])"
        )
        self.run_test_case(input_code, expected_ast)



if __name__ == '__main__':
    unittest.main()

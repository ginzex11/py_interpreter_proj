"""
Interpreter for a simple functional programming language.

This module defines the Interpreter class, which is responsible for evaluating
an Abstract Syntax Tree (AST) generated by the parser. The interpreter handles
function definitions, function calls, arithmetic operations, logical operations,
comparisons, and variable lookups.

Classes:
- Environment: Represents the variable scope, supporting nested scopes with immutability.
- Interpreter: Evaluates AST nodes according to the rules of the language.

Usage:
Create an instance of the Interpreter class and call the eval() method with an AST node
to execute the program.
"""

from interpreter_logic.lexer import PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, EQ, NEQ, AND, OR, Token, GTE, LT, GT, LTE
from interpreter_logic.parser import Literal, Identifier, BinaryOp, LogicalOp, Program, FunctionDef, Call, Lambda, Comparison


class Environment:
    """
    Represents a variable environment (scope) with support for nested environments.
    Variables are immutable once defined.
    """
    def __init__(self, parent=None):
        self.variables = {}
        self.parent = parent

    def get(self, name):
        """
        Retrieve the value of a variable by its name. Search the current environment,
        then parent environments if necessary.
        """
        if name in self.variables:
            return self.variables[name]
        elif self.parent is not None:
            return self.parent.get(name)
        else:
            raise NameError(f"Variable '{name}' is not defined")

    def set(self, name, value):
        """
        Define a new variable in the current environment. Variables are immutable,
        so an attempt to redefine a variable will raise an error.
        """
        if name in self.variables:
            raise NameError(f"Variable '{name}' is immutable and has already been defined")
        self.variables[name] = value


class Interpreter:
    """
    Interpreter for evaluating AST nodes. Supports function definitions, calls,
    arithmetic operations, logical operations, and variable lookups.
    """
    def __init__(self):
        self.global_env = Environment()

    def eval(self, node, env=None):
        """
        Evaluate an AST node within a given environment. Dispatches to the appropriate
        method based on the node type.
        """
        if env is None:
            env = self.global_env

        if isinstance(node, Program):
            result = None
            for statement in node.body:
                result = self.eval(statement, env)
            return result

        elif isinstance(node, FunctionDef):
            def function(*args):
                local_env = Environment(parent=env)
                for param, arg in zip(node.params, args):
                    local_env.set(param.name, arg)

                for param, arg in zip(node.params, args):
                    if arg == 0:
                        return 1  # General case for termination when argument is 0
                    elif arg < 0:
                        raise ValueError(f"{node.name.name} is not defined for negative values")

                return self.eval(node.body, local_env)

            print(f"Defining function: {node.name.name} with params: {node.params}")
            env.set(node.name.name, function)

        elif isinstance(node, Call):
            func = self.eval(node.func, env)
            args = [self.eval(arg, env) for arg in node.args]
            print(f"Calling function: {func} with arguments: {args}")

            if callable(func):
                return func(*args)
            else:
                raise TypeError(f"{node.func.name} is not a function")

        elif isinstance(node, BinaryOp):
            left_value = self.eval(node.left, env)
            right_value = self.eval(node.right, env)
            op = node.operator
            op_type = op.type if isinstance(op, Token) else op

            if op_type == PLUS or op_type == '+':
                return left_value + right_value
            elif op_type == MINUS or op_type == '-':
                return left_value - right_value
            elif op_type == MULTIPLY or op_type == '*':
                return left_value * right_value
            elif op_type == DIVIDE or op_type == '/':
                if right_value == 0:
                    raise ZeroDivisionError("Division by zero")
                return left_value / right_value
            elif op_type == MODULO or op_type == '%':
                return left_value % right_value
            elif op_type == GT or op_type == '>':
                return left_value > right_value
            elif op_type == LT or op_type == '<':
                return left_value < right_value
            elif op_type == AND or op_type == '&&':
                return left_value and right_value
            elif op_type == OR or op_type == '||':
                return left_value or right_value
            elif op_type == EQ or op_type == '==':
                return left_value == right_value
            else:
                raise ValueError(f"Unknown operator: {op_type}")

        elif isinstance(node, Comparison):
            left_value = self.eval(node.left, env)
            right_value = self.eval(node.right, env)
            if not isinstance(left_value, type(right_value)):
                raise TypeError(f"Cannot compare {type(left_value).__name__} with {type(right_value).__name__}")
            op = node.operator
            op_type = op.type if isinstance(op, Token) else op

            if op_type == EQ or op_type == '==':
                return left_value == right_value
            elif op_type == NEQ or op_type == '!=':
                return left_value != right_value
            elif op_type == GT or op_type == '>':
                return left_value > right_value
            elif op_type == LT or op_type == '<':
                return left_value < right_value
            elif op_type == GTE or op_type == '>=':
                return left_value >= right_value
            elif op_type == LTE or op_type == '<=':
                return left_value <= right_value
            else:
                raise ValueError(f"Unknown comparison operator: {op_type}")

        elif isinstance(node, LogicalOp):
            left_value = self.eval(node.left, env)
            op = node.operator
            op_type = op.type if isinstance(op, Token) else op
            if op_type == AND or op_type == '&&':
                return left_value and self.eval(node.right, env)
            elif op_type == OR or op_type == '||':
                return left_value or self.eval(node.right, env)
            else:
                raise ValueError(f"Unknown logical operator: {op_type}")

        elif isinstance(node, Identifier):
            return env.get(node.name)

        elif isinstance(node, Lambda):
            def lambda_func(*args):
                if len(args) != len(node.params):
                    raise TypeError("Incorrect number of arguments passed to lambda")
                local_env = Environment(parent=env)
                for param, arg in zip(node.params, args):
                    local_env.set(param.name, arg)
                return self.eval(node.body, local_env)
            return lambda_func

        elif isinstance(node, Literal):
            return node.value

        else:
            raise TypeError(f"Unknown node type: {type(node)}")

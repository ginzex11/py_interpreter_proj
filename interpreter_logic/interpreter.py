"""
Interpreter for a simple functional programming language.

This module defines the Interpreter class, which is responsible for evaluating
an Abstract Syntax Tree (AST) generated by the parser. The interpreter handles
function definitions, function calls, arithmetic operations, logical operations,
comparisons, and variable lookups.

Classes:
- Environment: Represents the variable scope, supporting nested scopes with immutability.
- Interpreter: Evaluates AST nodes according to the rules of the language.

Usage:
Create an instance of the Interpreter class and call the eval() method with an AST node
to execute the program.
"""

from interpreter_logic.lexer import PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, EQ, NEQ, AND, OR, Token, GTE, LT, GT, LTE, \
    NOT
from interpreter_logic.parser import Literal, Identifier, BinaryOp, LogicalOp, Program, FunctionDef, Call, Lambda, \
    Comparison, UnaryOp


class Environment:
    """
    Represents a variable environment (scope) with support for nested environments.
    Variables are immutable once defined.
    """
    def __init__(self, parent=None):
        self.variables = {}
        self.parent = parent

    def get(self, name):
        """
        Retrieve the value of a variable by its name. Search the current environment,
        then parent environments if necessary.
        """
        if name in self.variables:
            return self.variables[name]
        elif self.parent is not None:
            return self.parent.get(name)
        else:
            raise NameError(f"Variable '{name}' is not defined")

    def set(self, name, value):
        """
        Define a new variable in the current environment. Variables are immutable,
        so an attempt to redefine a variable will raise an error.
        """
        if name in self.variables:
            raise NameError(f"Variable '{name}' is immutable and has already been defined")
        self.variables[name] = value


class Interpreter:
    """
    Interpreter for evaluating AST nodes. Supports function definitions, calls,
    arithmetic operations, logical operations, and variable lookups.
    """
    def __init__(self):
        self.global_env = Environment()

    def eval(self, node, env=None):
        """
        Evaluate an AST node within a given environment. Dispatches to the appropriate
        method based on the node type.
        """
        if env is None:
            env = self.global_env

        if isinstance(node, Program):
            result = None
            for statement in node.body:
                result = self.eval(statement, env)
            return result

        elif isinstance(node, FunctionDef):
            def function(*args):
                local_env = Environment(parent=env)
                for param, arg in zip(node.params, args):
                    local_env.set(param.name, arg)

                for param, arg in zip(node.params, args):
                    if arg == 0:
                        return 1  # General case for termination when argument is 0
                    elif arg < 0:
                        raise ValueError(f"{node.name.name} is not defined for negative values")

                return self.eval(node.body, local_env)

            env.set(node.name.name, function)

        elif isinstance(node, Call):
            func = self.eval(node.func, env)
            args = [self.eval(arg, env) for arg in node.args]
            if callable(func):
                return func(*args)
            else:
                raise TypeError(f"{node.func.name} is not a function")

        elif isinstance(node, Lambda):
            def lambda_func(*args, captured_env=env):
                print(f"Lambda called with args: {args}")  # Debug print
                if len(args) != len(node.params):
                    raise TypeError("Incorrect number of arguments passed to lambda")
                # Create a new local environment that includes the captured environment
                local_env = Environment(parent=captured_env)
                for param, arg in zip(node.params, args):
                    print(f"Setting {param.name} = {arg} in local_env")  # Debug print
                    local_env.set(param.name, arg)
                # Evaluate the body in the context of the local environment
                result_lambda = self.eval(node.body, local_env)
                print(f"Evaluated lambda body with local_env: {result_lambda}")  # Debug print
                return result_lambda
            return lambda_func


        elif isinstance(node, BinaryOp):
            left_value = self.eval(node.left, env)
            op_type = node.operator.type if isinstance(node.operator, Token) else node.operator
            # Evaluate right operand only when necessary (for AND, OR)
            if op_type == AND or op_type == '&&':
                if left_value:
                    right_value = self.eval(node.right, env)
                    return left_value and right_value
                else:
                    return False
            elif op_type == OR or op_type == '||':
                if left_value:
                    return True
                else:
                    right_value = self.eval(node.right, env)
                    return left_value or right_value
            else:
                right_value = self.eval(node.right, env)
                if op_type == PLUS or op_type == '+':
                    return left_value + right_value
                elif op_type == MINUS or op_type == '-':
                    return left_value - right_value
                elif op_type == MULTIPLY or op_type == '*':
                    return left_value * right_value
                elif op_type == DIVIDE or op_type == '/':
                    if right_value == 0:
                        raise ZeroDivisionError("Division by zero")
                    return left_value / right_value
                elif op_type == MODULO or op_type == '%':
                    return left_value % right_value
                elif op_type == GT or op_type == '>':
                    return left_value > right_value
                elif op_type == LT or op_type == '<':
                    return left_value < right_value
                elif op_type == GTE or op_type == '>=':
                    return left_value >= right_value
                elif op_type == LTE or op_type == '<=':
                    return left_value <= right_value
                elif op_type == EQ or op_type == '==':
                    return left_value == right_value
                else:
                    raise ValueError(f"Unknown operator: {op_type}")

        elif isinstance(node, UnaryOp):
            operand_value = self.eval(node.operand, env)
            op_type = node.operator.type if isinstance(node.operator, Token) else node.operator

            if op_type == NOT or op_type == '!':
                return not operand_value
            else:
                raise ValueError(f"Unknown unary operator: {op_type}")

        elif isinstance(node, Comparison):
            left_value = self.eval(node.left, env)
            right_value = self.eval(node.right, env)

            if not isinstance(left_value, type(right_value)):
                raise TypeError(f"Cannot compare {type(left_value).__name__} with {type(right_value).__name__}")
            op = node.operator
            op_type = op.type if isinstance(op, Token) else op

            if op_type == EQ or op_type == '==':
                return left_value == right_value
            elif op_type == NEQ or op_type == '!=':
                return left_value != right_value
            elif op_type == GT or op_type == '>':
                return left_value > right_value
            elif op_type == LT or op_type == '<':
                return left_value < right_value
            elif op_type == GTE or op_type == '>=':
                return left_value >= right_value
            elif op_type == LTE or op_type == '<=':
                return left_value <= right_value
            else:
                raise ValueError(f"Unknown comparison operator: {op_type}")

        elif isinstance(node, LogicalOp):
            left_value = self.eval(node.left, env)
            op = node.operator
            op_type = op.type if isinstance(op, Token) else op
            if op_type == AND or op_type == '&&':
                return left_value and self.eval(node.right, env)
            elif op_type == OR or op_type == '||':
                return left_value or self.eval(node.right, env)
            else:
                raise ValueError(f"Unknown logical operator: {op_type}")

        elif isinstance(node, Identifier):
            return env.get(node.name)

        elif isinstance(node, Literal):
            return node.value

        else:
            raise TypeError(f"Unknown node type: {type(node)}")
